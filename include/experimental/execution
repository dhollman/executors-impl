#ifndef STD_EXPERIMENTAL_EXECUTION
#define STD_EXPERIMENTAL_EXECUTION

#include <experimental/bits/require.h>
#include <experimental/bits/prefer.h>
#include <experimental/bits/query.h>

#include <variant> // monostate

namespace std {
namespace experimental {
inline namespace executors_v1 {
namespace execution {

namespace
{
  // Require customization point.
  constexpr const auto& require = require_impl::customization_point<>;

  // Prefer customization point.
  constexpr const auto& prefer = prefer_impl::customization_point<>;

  // Query customization point.
  constexpr const auto& query = query_impl::customization_point<>;
}

// Type trait to determine whether the require customization point is valid for the specified arguments.
template<class Executor, class... Properties> struct can_require;

template<class Executor, class... Properties>
  constexpr bool can_require_v = can_require<Executor, Properties...>::value;

// Type trait to determine whether the prefer customization point is valid for the specified arguments.
template<class Executor, class... Properties> struct can_prefer;

template<class Executor, class... Properties>
  constexpr bool can_prefer_v = can_prefer<Executor, Properties...>::value;

// Type trait to determine whether the query customization point is valid for the specified arguments.
template<class Executor, class Property> struct can_query;

template<class Executor, class Property>
  constexpr bool can_query_v = can_query<Executor, Property>::value;

// Associated execution context.
struct context_t;

//// Directionality.
//struct oneway_t;
//struct twoway_t;
//
//// Cardinality.
//struct single_t;
//struct bulk_t;
//
// Blocking behaviour.
struct blocking_t;


// Allow adaptation of blocking and directionality (e.g. twoway in terms of oneway).
struct blocking_adaptation_t;

// Whether submitted tasks represent a fork or continuation of the control flow.
struct relationship_t;

// Whether there is outstanding work, i.e. an indication of likely task submission in the future.
struct outstanding_work_t;

// Properties for bulk execution forward progress guarantees.
struct bulk_guarantee_t;

// Properties for mapping of execution on to threads.
struct mapping_t;


// Memory allocations.
template<class ProtoAllocator> struct allocator_t;

template<class VSubEx=void, class ESubEx=void>
struct then_t;

// Type traits to determine conformance to executor type requirements.
template<class Executor, class T, class E, typename R, typename S, class VSubEx, class ESubEx> struct is_continuation;
template<class Executor, class T, class E, class VSubEx, class ESubEx> struct is_executor;
template<class Executor, class T, class E, class VSubEx, class ESubEx> struct is_then_executor;

template<class Executor, class T, class E, typename R, typename S, class VSubEx, class ESubEx>
constexpr bool is_continuation_v = is_continuation<Executor, T, E, R, S, VSubEx, ESubEx>::value;
template<class Executor, class T=void, class E=exception_ptr, class VSubEx=Executor, class ESubEx=Executor>
constexpr bool is_executor_v = is_executor<Executor, T, E, VSubEx, ESubEx>::value;
template<class Executor, class T=void, class E=exception_ptr, class R=void, class S=exception_ptr, class VSubEx=Executor, class ESubEx=Executor, class RetEx=Executor>
constexpr bool is_then_executor_v = is_then_executor<Executor, T, E, VSubEx, ESubEx>::value;

template <typename Executor>
struct executor_value;
template <typename Executor>
struct executor_error;


template <typename Executor>
using executor_value_t = typename executor_value<Executor>::type;
template <typename Executor>
using executor_error_t = typename executor_error<Executor>::type;

// Polymorphic wrappers.
class bad_executor;
template<class T, class E, class... SupportableProperties> class executor;
template<class InnerProperty> struct prefer_only;

// helpers functions
template <class TypeForVoid=monostate, class ValueCallable, class ErrorCallable, class... Args>
auto make_continuation(ValueCallable&& vc, ErrorCallable&& ec, Args&&... args);

template <class NullaryCallable>
auto on_void(NullaryCallable&& nc);

template <class UnaryCallable>
auto on_value(UnaryCallable&& nc);

template <class BinaryCallable>
auto on_value_with_subexecutor(BinaryCallable&& nc);

template <class UnaryCallable>
inline auto on_error(UnaryCallable&& nc);

template <class BinaryCallable>
inline auto on_error_with_subexecutor(BinaryCallable&& nc);

} // namespace execution
} // inline namespace executors_v1
} // namespace experimental
} // namespace std

#include <experimental/bits/can_require.h>
#include <experimental/bits/can_prefer.h>
#include <experimental/bits/can_query.h>
#include <experimental/bits/is_continuation.h>
#include <experimental/bits/is_executor.h>
#include <experimental/bits/is_then_executor.h>
#include <experimental/bits/executor_value.h>
#include <experimental/bits/executor_error.h>

#include <experimental/bits/then.h>

#include <experimental/bits/context.h>
#include <experimental/bits/helpers.h>

#include <experimental/bits/blocking.h>
#include <experimental/bits/blocking_adaptation.h>
#include <experimental/bits/relationship.h>
#include <experimental/bits/outstanding_work.h>
#include <experimental/bits/bulk_guarantee.h>
#include <experimental/bits/mapping.h>
#include <experimental/bits/allocator.h>


#include <experimental/bits/executor.h>
#include <experimental/bits/prefer_only.h>


#endif // STD_EXPERIMENTAL_EXECUTION
